一点笔记

​	*<small>基于王爽《汇编语言》进行学习</small>*

# 1. 寄存器

## 1.1 重点处

**cs**和**ip**是最重要的两个寄存器，cs为代码段寄存器，ip为指令指针寄存器。

在8086pc机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取下一条指令。

1. 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器。
2. IP=IP+所读取指令的长度，从而读取下一条指令。
3. 执行指令，转到步骤1，重复这个过程。

##1.2 debug常用指令

- r 查看、改编cpu寄存器的内容；

  > 比如，你要修改寄存器ax的值就r ax然后debug就会
  >
  > :
  >
  > 你就输入你想修改的数值就行了

- d 查看内存的内容；

- e 改写内存的内容；

- u 将机器指令翻译成汇编指令；

- t 执行一条机器指令；

- a 以汇编指令的格式在内存中写入一条机器指令。

## 1.3 基于内存访问的寄存器

16位一个字，8位一个字节

### 关于ds

8086中有一个ds寄存器，通常用来存放要访问数据的段地址。

读取10000H单元的内容时：

``` assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

"[...]"表示一个内存单元，扩起内容表示内存单元的**偏移地址**。我们知道只有偏移地址是不能定位内存单元的，段地址是啥呢，不用担心，指令执行时cpu自动取ds中的数据为段地址，所以我们才要在前面mov一下。

那为什么我们不能直接`mov ds,1000H`？反正就是不行。

### 关于栈

- LIFO
- 8086cpu中有两个寄存器，段寄存器ss和寄存器sp，**任意时刻，SS:SP指向栈顶元素**。

# 2. 汇编程序

### 2.1 伪指令

- segment对ends

- end代表整个程序结束

- 基本格式是这样的我还是抄一段书把

  ``` assembly
  assume cs:codesg
  codesg segment
  	mov ax,0123H
  	...
  	
  codesg ends
  end
  ```

### 2.2 过程

程序最先以汇编指令的形式存在于源程序中，经过**编译、连接**后转变为机器码，储存在**可执行文件**中。

# 3. 数据处理

计算机是进行数据处理、运算的机器，所以有两个问题出现在了我们面前：

1. 处理的数据在什么地方？
2. 要处理的数据有多长？

两个描述性符号：reg和sreg。

`reg（寄存器）:ax bx cx dx ah al bh bl ch cl dh dl sp bp si di`

`sreg（段寄存器）:ds ss cs es`



### 3.1 bx si  di dp

**只有这四个可以用在[...]中寻址！！！**

mov ax,[cx] 错误！！！

### 3.2 数据的位置

汇编中用三个概念来表达数据的位置：

- 立即数（idata）

  直接包含在机器指令中的数据。例如，mov ax,1

- 寄存器

- 段地址（SA）和偏移地址（EA）

### 3.3 寻址方式

给你一张表你自己看

![image-20191030201523525](/Users/moanbigking/Library/Application Support/typora-user-images/image-20191030201523525.png)

### 3.4 数据长度

8086cpu可以处理的数据有两种长度，byte和word。所以在机器指令中要指明需要进行的是字操作还是字节操作。

方法有如下几种：

1. 通过寄存器名称指明。

   比如mov的时候用ax就是字操作用al就是字节操作。

2. 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编中可为byte或word。

   以下用`word ptr`表明访问的单元是一个字单元。

   ``` assembly
   mov word ptr ds:[0],1
   inc word ptr [bx]
   ```

   以下用法`byte ptr`表明访问的单元是一个字节单元。

   ``` assembly
   mov byte ptr ds:[0],1
   inc byte ptr [bx]
   ```

3. 其他方法

   有些指令默认访问的是字单元还是字节单元，比如push[1000H]注定只能访问字单元。

