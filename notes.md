一点笔记

​	*<small>基于王爽《汇编语言》进行学习</small>*

# 1. 寄存器

## 1.1 重点处

**cs**和**ip**是最重要的两个寄存器，cs为代码段寄存器，ip为指令指针寄存器。

在8086pc机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取下一条指令。

1. 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器。
2. IP=IP+所读取指令的长度，从而读取下一条指令。
3. 执行指令，转到步骤1，重复这个过程。

##1.2 debug常用指令

- r 查看、改编cpu寄存器的内容；

  > 比如，你要修改寄存器ax的值就r ax然后debug就会
  >
  > :
  >
  > 你就输入你想修改的数值就行了

- d 查看内存的内容；

- e 改写内存的内容；

- u 将机器指令翻译成汇编指令；

- t 执行一条机器指令；

- a 以汇编指令的格式在内存中写入一条机器指令。

## 1.3 基于内存访问的寄存器

16位一个字，8位一个字节

### 关于ds

8086中有一个ds寄存器，通常用来存放要访问数据的段地址。

读取10000H单元的内容时：

``` assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

"[...]"表示一个内存单元，扩起内容表示内存单元的**偏移地址**。我们知道只有偏移地址是不能定位内存单元的，段地址是啥呢，不用担心，指令执行时cpu自动取ds中的数据为段地址，所以我们才要在前面mov一下。

那为什么我们不能直接`mov ds,1000H`？反正就是不行。

### 关于栈

- LIFO
- 8086cpu中有两个寄存器，段寄存器ss和寄存器sp，**任意时刻，SS:SP指向栈顶元素**。

# 2. 汇编程序

### 2.1 伪指令

- segment对ends

- end代表整个程序结束

- 基本格式是这样的我还是抄一段书把

  ``` assembly
  assume cs:codesg
  codesg segment
  	mov ax,0123H
  	...
  	
  codesg ends
  end
  ```

### 2.2 过程

程序最先以汇编指令的形式存在于源程序中，经过**编译、连接**后转变为机器码，储存在**可执行文件**中。



